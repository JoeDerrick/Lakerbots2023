// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import frc.robot.commands.*;
import frc.robot.commands.IntakeCommands.IntakeMotorGo;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
//import edu.wpi.first.wpilibj.motorcontrol.CANSparkMax;

import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.util.Color;

//import com.revrobotics.ColorSensorV2;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class intake extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax intakeMotor;
//private CANSparkMax intakeMotorRight;
//private CANSparkMax intakeMotorSqueeze;
public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput;
//private final ColorSensorV2 m_colorSensor = new ColorSensorV2(1000); // <--- CHANGE VALUE
private SparkMaxPIDController m_pidController;
private RelativeEncoder m_encoder;

public double positionA = 100;//placeholder
public double positionHome = 0;
public double setPoint;

public double inPositionThreshold = 1.0;

public double coneThreshhold = 45;
public double cubeThreshhold = 25;
/*m_pidController = intakeMotorSqueeze.getPIDController();

m_encoder = intakeMotorLeft.getEncoder();
*/

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */
    public intake() {

       

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
intakeMotor = new CANSparkMax(16, MotorType.kBrushless);
 //addChild("intakeMotorLeft",intakeMotorLeft);
 intakeMotor.setInverted(false);

//intakeMotorRight = new CANSparkMax(17, MotorType.kBrushless);
 //addChild("intakeMotorRight",intakeMotorRight);
 //intakeMotorRight.setInverted(false);

//intakeMotorSqueeze = new CANSparkMax(18, MotorType.kBrushless);
 //addChild("intakeMotorSqueeze",intakeMotorSqueeze);
 //intakeMotorSqueeze.setInverted(false);

 m_pidController = intakeMotor.getPIDController();

 // Encoder object created to display position values
 //m_encoder = intakeMotorSqueeze.getEncoder();

 // PID coefficients
 kP = 0.1; 
 kI = 1e-4;
 kD = 1;  
 kIz = 0; 
 kFF = 0; 
 kMaxOutput = 1; 
 kMinOutput = -1;

 // set PID coefficients
 m_pidController.setP(kP);
 m_pidController.setI(kI);
 m_pidController.setD(kD);
 m_pidController.setIZone(kIz);
 m_pidController.setFF(kFF);
 m_pidController.setOutputRange(kMinOutput, kMaxOutput);


//colorSensorV2 = new DigitalInput(2);
 //addChild("colorSensorV2", colorSensorV2);
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    public void intakeMotorGo(double percent){
        intakeMotor.set(percent);
    }
    public void intakeMotorStop(){
        intakeMotor.set(0);
    }

    public double getIntakeMotorCurrent(){
        return intakeMotor.getOutputCurrent();
    }

    public boolean cubeIsIntaked(){
        if (Math.abs(getIntakeMotorCurrent()) > cubeThreshhold){
            return true;
        }
        else{
            return false;
        }
    }

    public boolean gamePieceIsIntaked(){
        if (Math.abs(getIntakeMotorCurrent()) > coneThreshhold){
            return true;
        }
        else{
            return false;
        }
    }
    /* 
    public void intakeMotorRightGo(){
        intakeMotorRight.set(25);
    }
    public void intakeMotorRightStop(){
        intakeMotorRight.set(0);
    }
    /*public void GetColor(){
        colorSensorV2.getColor();
    }
    */
    public void intakeHold(){
        setPoint = setPoint; // <-- not needed?
        m_pidController.setReference(setPoint, CANSparkMax.ControlType.kSmartMotion);
    }
    public void squeeze(){
        setPoint = positionA;
        m_pidController.setReference(setPoint, CANSparkMax.ControlType.kSmartMotion);
    }
    public void release(){
        setPoint = positionHome;
        m_pidController.setReference(setPoint, CANSparkMax.ControlType.kSmartMotion);
    }
    public double SqueezeGetPosition(){
        double processVariable = m_encoder.getPosition();
        return processVariable;
    }
    public boolean squeezeAtTargetPosition(){
        double currentPosition = m_encoder.getPosition();
        double targetPosition = setPoint;
        double positionError = Math.abs(targetPosition - currentPosition);
        if (positionError < inPositionThreshold) {
          return true;
        }
        else {
          return false;
        }
    }

    @Override
    public void periodic() {


        /* */
        SmartDashboard.putNumber("intake current", getIntakeMotorCurrent());
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("P Gain", kP);
    SmartDashboard.putNumber("I Gain", kI);
    SmartDashboard.putNumber("D Gain", kD);
    SmartDashboard.putNumber("I Zone", kIz);
    SmartDashboard.putNumber("Feed Forward", kFF);
    SmartDashboard.putNumber("Max Output", kMaxOutput);
    SmartDashboard.putNumber("Min Output", kMinOutput);
    SmartDashboard.putNumber("Set Rotations", 0);
    double p = SmartDashboard.getNumber("P Gain", 0);
    double i = SmartDashboard.getNumber("I Gain", 0);
    double d = SmartDashboard.getNumber("D Gain", 0);
    double iz = SmartDashboard.getNumber("I Zone", 0);
    double ff = SmartDashboard.getNumber("Feed Forward", 0);
    double max = SmartDashboard.getNumber("Max Output", 0);
    double min = SmartDashboard.getNumber("Min Output", 0);
    double rotations = SmartDashboard.getNumber("Set Rotations", 0);

    // if PID coefficients on SmartDashboard have changed, write new values to controller
    if((p != kP)) { m_pidController.setP(p); kP = p; }
    if((i != kI)) { m_pidController.setI(i); kI = i; }
    if((d != kD)) { m_pidController.setD(d); kD = d; }
    if((iz != kIz)) { m_pidController.setIZone(iz); kIz = iz; }
    if((ff != kFF)) { m_pidController.setFF(ff); kFF = ff; }
    if((max != kMaxOutput) || (min != kMinOutput)) { 
      m_pidController.setOutputRange(min, max); 
      kMinOutput = min; kMaxOutput = max; 

    }
}

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

}

