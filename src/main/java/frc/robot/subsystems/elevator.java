// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import com.ctre.phoenix.motorcontrol.LimitSwitchNormal;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;

import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.ElevatorConstants;
import frc.robot.Instrum;




/**
 *
 */
public class elevator extends SubsystemBase {
  
    private WPI_TalonFX elevatorMotor;
    
    public double setpoint;
    
    public double inPositionThreshold = 150;
    
    private final XboxController xboxController1 = new XboxController(1);
    
    StringBuilder _sb = new StringBuilder();
    
    int _pov = -1;
    
    //How much smoothing to use [0,8]
    int _smoothing = 0;
   
    /** 

    */
    public elevator() {
        
    elevatorMotor = new WPI_TalonFX(14);
    //elevatorMotor.configForwardLimitSwitchSource(TalonFXFeedbackDevice.RemoteSensor0, true);

   
    elevatorMotor.configFactoryDefault();
    elevatorMotor.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor, ElevatorConstants.kPIDLoopIdx,
    ElevatorConstants.kTimeoutMs);

    elevatorMotor.setNeutralMode(NeutralMode.Brake);
  

    elevatorMotor.setInverted(false);
    
    elevatorMotor.configNeutralDeadband(0.001, ElevatorConstants.kTimeoutMs);
    elevatorMotor.setSensorPhase(false);
    elevatorMotor.setInverted(false);

    /* Set relevant frame periods to be at least as fast as periodic rate */
    elevatorMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, ElevatorConstants.kTimeoutMs);
    elevatorMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, ElevatorConstants.kTimeoutMs);

    /* Set the peak and nominal outputs */
    elevatorMotor.configNominalOutputForward(0, ElevatorConstants.kTimeoutMs);
    elevatorMotor.configNominalOutputReverse(0, ElevatorConstants.kTimeoutMs);
    elevatorMotor.configPeakOutputForward(1, ElevatorConstants.kTimeoutMs);
    elevatorMotor.configPeakOutputReverse(-1, ElevatorConstants.kTimeoutMs);

    /* Set Motion Magic gains in slot0 - see documentation */
    elevatorMotor.selectProfileSlot(ElevatorConstants.kSlotIdx, ElevatorConstants.kPIDLoopIdx);
    elevatorMotor.config_kF(ElevatorConstants.kSlotIdx,0.35, ElevatorConstants.kTimeoutMs);
    elevatorMotor.config_kP(ElevatorConstants.kSlotIdx, 0.4, ElevatorConstants.kTimeoutMs);
    elevatorMotor.config_kI(ElevatorConstants.kSlotIdx, 0, ElevatorConstants.kTimeoutMs);
    elevatorMotor.config_kD(ElevatorConstants.kSlotIdx, 0, ElevatorConstants.kTimeoutMs);

    /* Set acceleration and vcruise velocity - see documentation */
    elevatorMotor.configMotionCruiseVelocity(20000, ElevatorConstants.kTimeoutMs);//20000---------------------------20000
    elevatorMotor.configMotionAcceleration(40000, ElevatorConstants.kTimeoutMs);//50000-------------------------max is 40000

    /* Zero the sensor once on robot boot up */
    elevatorMotor.setSelectedSensorPosition(0, ElevatorConstants.kPIDLoopIdx, ElevatorConstants.kTimeoutMs);
   

   
    }

    public void elevatorSetVelocity(double velocity){
        elevatorMotor.configMotionCruiseVelocity(velocity, ElevatorConstants.kTimeoutMs);
    }
    public void elevatorSetAcceleration(double acceleration){
        elevatorMotor.configMotionAcceleration(acceleration, ElevatorConstants.kTimeoutMs);//50000-------------------------max is 40000

    }

    public void elevatorGoToPosition(double Position){
        setpoint = Position;
        elevatorMotor.set(TalonFXControlMode.MotionMagic, setpoint);
    }
    public double elevatorGetPosition(){
        return elevatorMotor.getSelectedSensorPosition();
    }
    public void resetElevator(){
        elevatorMotor.setSelectedSensorPosition(0);
    }
    public boolean elevatorAtTargetPosition(){
        double currentPosition = elevatorGetPosition();
        double targetPosition = setpoint;
        double positionError = Math.abs(targetPosition - currentPosition);
        if(positionError < inPositionThreshold){
            return true;
        }
        else{
            return false;
        }
    }
    public void elevatorJoystick(double y){
        elevatorMotor.set(TalonFXControlMode.PercentOutput, y);
    }
    public double elevatorGetVelocity(){
        return elevatorMotor.getSelectedSensorVelocity();
    }
    public void   elevatorTune(){
		/* Get gamepad axis - forward stick is positive */
		double leftYstick = -1.0 * xboxController1.getLeftY(); /* left-side Y for Xbox360Gamepad */
		double rghtYstick = -1.0 * xboxController1.getRightY(); /* right-side Y for Xbox360Gamepad */
		if (Math.abs(leftYstick) < 0.10) { leftYstick = 0; } /* deadband 10% */
		if (Math.abs(rghtYstick) < 0.10) { rghtYstick = 0; } /* deadband 10% */

		/* Get current Talon FX motor output */
		double motorOutput = elevatorMotor.getMotorOutputPercent();

		/* Prepare line to print */
		_sb.append("\tOut%:");
		_sb.append(motorOutput);
		_sb.append("\tVel:");
		_sb.append(elevatorMotor.getSelectedSensorVelocity(ElevatorConstants.kPIDLoopIdx));

		/**
		 * Perform Motion Magic when Button 1 is held, else run Percent Output, which can
		 * be used to confirm hardware setup.
		 */
		if (xboxController1.getRawButton(1)) {
			/* Motion Magic */

			/* 2048 ticks/rev * 10 Rotations in either direction */
			double targetPos = rghtYstick * 2048 * 10.0;
			elevatorMotor.set(TalonFXControlMode.MotionMagic, targetPos);

			/* Append more signals to print when in speed mode */
			_sb.append("\terr:");
			_sb.append(elevatorMotor.getClosedLoopError(ElevatorConstants.kPIDLoopIdx));
			_sb.append("\ttrg:");
			_sb.append(targetPos);
		} else {
			/* Percent Output */

			elevatorMotor.set(TalonFXControlMode.PercentOutput, leftYstick);
		}
		if (xboxController1.getRawButton(2)) {
			/* Zero sensor positions */
			elevatorMotor.setSelectedSensorPosition(0);
		}

		int pov = xboxController1.getPOV();
		if (_pov == pov) {
			/* no change */
		} else if (_pov == 180) { // D-Pad down
			/* Decrease smoothing */
			_smoothing--;
			if (_smoothing < 0)
				_smoothing = 0;
			elevatorMotor.configMotionSCurveStrength(_smoothing);

			System.out.println("Smoothing is set to: " + _smoothing);
		} else if (_pov == 0) { // D-Pad up
			/* Increase smoothing */
			_smoothing++;
			if (_smoothing > 8)
				_smoothing = 8;
			elevatorMotor.configMotionSCurveStrength(_smoothing);

			System.out.println("Smoothing is set to: " + _smoothing);
		}
		_pov = pov; /* save the pov value for next time */

		/* Instrumentation */
		Instrum.Process(elevatorMotor, _sb);
	}


    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        //System.out.println(+elevatorGetVelocity());
        SmartDashboard.putNumber("Elevator Velocity", elevatorGetVelocity());
        SmartDashboard.putNumber("Elevator Position", elevatorGetPosition());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

}

