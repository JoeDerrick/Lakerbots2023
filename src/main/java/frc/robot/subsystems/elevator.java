// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonFX;

import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Instrum;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class elevator extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private TalonFX elevatorMotor;
    
    public double setpoint;
    
    public double inPositionThreshold = 10;
    
    private final XboxController xboxController1 = new XboxController(1);
    
    StringBuilder _sb = new StringBuilder();
    
    int _pov = -1;
    
    //How much smoothing to use [0,8]
    int _smoothing = 0;
   
    /**

    */
    public elevator() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    elevatorMotor = new TalonFX(14);
    elevatorMotor.configFactoryDefault();
    elevatorMotor.setNeutralMode(NeutralMode.Brake);
  

    elevatorMotor.setInverted(false);
    elevatorMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, Constants.kPIDLoopIdx,
    Constants.kTimeoutMs);
    elevatorMotor.configNeutralDeadband(0.001, Constants.kTimeoutMs);
    elevatorMotor.setSensorPhase(false);
    elevatorMotor.setInverted(false);

    /* Set relevant frame periods to be at least as fast as periodic rate */
    elevatorMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, Constants.kTimeoutMs);
    elevatorMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, Constants.kTimeoutMs);

    /* Set the peak and nominal outputs */
    elevatorMotor.configNominalOutputForward(0, Constants.kTimeoutMs);
    elevatorMotor.configNominalOutputReverse(0, Constants.kTimeoutMs);
    elevatorMotor.configPeakOutputForward(1, Constants.kTimeoutMs);
    elevatorMotor.configPeakOutputReverse(-1, Constants.kTimeoutMs);

    /* Set Motion Magic gains in slot0 - see documentation */
    elevatorMotor.selectProfileSlot(Constants.kSlotIdx, Constants.kPIDLoopIdx);
    elevatorMotor.config_kF(Constants.kSlotIdx, Constants.kGains.kF, Constants.kTimeoutMs);
    elevatorMotor.config_kP(Constants.kSlotIdx, Constants.kGains.kP, Constants.kTimeoutMs);
    elevatorMotor.config_kI(Constants.kSlotIdx, Constants.kGains.kI, Constants.kTimeoutMs);
    elevatorMotor.config_kD(Constants.kSlotIdx, Constants.kGains.kD, Constants.kTimeoutMs);

    /* Set acceleration and vcruise velocity - see documentation */
    elevatorMotor.configMotionCruiseVelocity(100, Constants.kTimeoutMs);
    elevatorMotor.configMotionAcceleration(50, Constants.kTimeoutMs);

    /* Zero the sensor once on robot boot up */
    elevatorMotor.setSelectedSensorPosition(0, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

   
    }

    public void elevatorGoToPosition(double Position){
        setpoint = Position;
        elevatorMotor.set(ControlMode.MotionMagic, setpoint);
    }
    public double elevatorGetPosition(){
        return elevatorMotor.getSelectedSensorPosition();
    }
    public boolean elevatorAtTargetPosition(){
        double currentPosition = elevatorGetPosition();
        double targetPosition = setpoint;
        double positionError = Math.abs(targetPosition - currentPosition);
        if(positionError < inPositionThreshold){
            return true;
        }
        else{
            return false;
        }
    }
    public void elevatorJoystick(double y){
        elevatorMotor.set(ControlMode.PercentOutput, y);
    }
    public double elevatorGetVelocity(){
        return elevatorMotor.getSelectedSensorVelocity();
    }
    public void   elevatorTune(){
		/* Get gamepad axis - forward stick is positive */
		double leftYstick = -1.0 * xboxController1.getLeftY(); /* left-side Y for Xbox360Gamepad */
		double rghtYstick = -1.0 * xboxController1.getRightY(); /* right-side Y for Xbox360Gamepad */
		if (Math.abs(leftYstick) < 0.10) { leftYstick = 0; } /* deadband 10% */
		if (Math.abs(rghtYstick) < 0.10) { rghtYstick = 0; } /* deadband 10% */

		/* Get current Talon FX motor output */
		double motorOutput = elevatorMotor.getMotorOutputPercent();

		/* Prepare line to print */
		_sb.append("\tOut%:");
		_sb.append(motorOutput);
		_sb.append("\tVel:");
		_sb.append(elevatorMotor.getSelectedSensorVelocity(Constants.kPIDLoopIdx));

		/**
		 * Perform Motion Magic when Button 1 is held, else run Percent Output, which can
		 * be used to confirm hardware setup.
		 */
		if (xboxController1.getRawButton(1)) {
			/* Motion Magic */

			/* 2048 ticks/rev * 10 Rotations in either direction */
			double targetPos = rghtYstick * 2048 * 10.0;
			elevatorMotor.set(TalonFXControlMode.MotionMagic, targetPos);

			/* Append more signals to print when in speed mode */
			_sb.append("\terr:");
			_sb.append(elevatorMotor.getClosedLoopError(Constants.kPIDLoopIdx));
			_sb.append("\ttrg:");
			_sb.append(targetPos);
		} else {
			/* Percent Output */

			elevatorMotor.set(TalonFXControlMode.PercentOutput, leftYstick);
		}
		if (xboxController1.getRawButton(2)) {
			/* Zero sensor positions */
			elevatorMotor.setSelectedSensorPosition(0);
		}

		int pov = xboxController1.getPOV();
		if (_pov == pov) {
			/* no change */
		} else if (_pov == 180) { // D-Pad down
			/* Decrease smoothing */
			_smoothing--;
			if (_smoothing < 0)
				_smoothing = 0;
			elevatorMotor.configMotionSCurveStrength(_smoothing);

			System.out.println("Smoothing is set to: " + _smoothing);
		} else if (_pov == 0) { // D-Pad up
			/* Increase smoothing */
			_smoothing++;
			if (_smoothing > 8)
				_smoothing = 8;
			elevatorMotor.configMotionSCurveStrength(_smoothing);

			System.out.println("Smoothing is set to: " + _smoothing);
		}
		_pov = pov; /* save the pov value for next time */

		/* Instrumentation */
		Instrum.Process(elevatorMotor, _sb);
	}


    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        //System.out.println(+elevatorGetVelocity());
        
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

}

